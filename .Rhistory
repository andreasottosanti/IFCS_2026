adj_manual
adj_manual <- apply(W, 1, function(x) which(x == 1))
adj_manual
lapply(adj_manual, length)
knn_res <- dbscan::kNN(cbind(sce$row, sce$col), k = 6)
adj_manual <- knn_res$id
adj_manual
set.seed(123)
sce_colData <- cbind(row = as.numeric(as.character(round(spatialCoords(x)[,1]))),
col = as.numeric(as.character(round(spatialCoords(x)[,2]))),
colData(x))
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
reducedDim(sce, "GLMPCA") <- reducedDim(x)
sce <- spatialPreprocess(sce, platform="ST", skip.PCA = T)
sce@metadata$BayesSpace.data$adj <- adj_manual
colnames(sce) <- as.character(seq_len(ncol(sce)))
colnames(sce)
rownames(adj_manual)
rownames(adj_manual) <- colnames(sce)
rownames(adj_manual)
names(rowData(sce))[1] <- "symbol"
sce <- BayesSpace::spatialCluster(sce = sce, q = K,
use.dimred = "GLMPCA",
d = selected_pca,
platform = "ST",
nrep = R, burn.in = R/2)
sce@metadata$BayesSpace.data
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = F)
reducedDims(sce)
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
reducedDim(sce, "GLMPCA") <- reducedDim(x)
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = F)
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = F)
sce@metadata$BayesSpace.data$adj <- adj_manual
colnames(sce) <- as.character(seq_len(ncol(sce)))
rownames(adj_manual) <- colnames(sce)
names(rowData(sce))[1] <- "symbol"
sce <- BayesSpace::spatialCluster(sce = sce, q = K,
d = selected_pca,
platform = "ST",
nrep = R, burn.in = R/2)
sce$sample_id
metadata(sce)$BayesSpace.data$sample.ids <- "sample01"
metadata(sce)$BayesSpace.data$adj
sce_colData <- cbind(row = as.numeric(as.character(round(spatialCoords(x)[,1]))),
col = as.numeric(as.character(round(spatialCoords(x)[,2]))),
colData(x))
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = F)
sce@metadata$BayesSpace.data$adj <- adj_manual
metadata(sce)$BayesSpace.data$sample.ids <- "sample01"
colnames(sce) <- as.character(seq_len(ncol(sce)))
rownames(adj_manual) <- colnames(sce)
names(rowData(sce))[1] <- "symbol"
sce <- BayesSpace::spatialCluster(sce = sce, q = K,
d = selected_pca,
platform = "ST",
nrep = R, burn.in = R/2)
set.seed(123)
sce_colData <- cbind(row = as.numeric(as.character(round(spatialCoords(x)[,1]))),
col = as.numeric(as.character(round(spatialCoords(x)[,2]))),
colData(x))
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
colnames(sce) <- as.character(seq_len(ncol(sce)))
rownames(adj_manual) <- colnames(sce)
names(rowData(sce))[1] <- "symbol"
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = F)
sce@metadata$BayesSpace.data$adj <- adj_manual
metadata(sce)$BayesSpace.data$sample.ids <- "sample01"
sce <- BayesSpace::spatialCluster(sce = sce, q = K,
d = selected_pca,
platform = "ST",
nrep = R, burn.in = R/2)
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
# 1. Setup iniziale nomi
colnames(sce) <- as.character(seq_len(ncol(sce)))
rownames(adj_manual) <- colnames(sce)
# IMPORTANTE: BayesSpace cerca "sample_id" nel colData
sce$sample_id <- "sample01"
# 2. Preprocess (crea lo scheletro)
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = FALSE)
# 3. Iniezione manuale e sincronizzazione (IL FIX)
# Dobbiamo assicurarci che i metadati sappiano che esiste "sample01"
metadata(sce)$BayesSpace.data$adj <- as.matrix(adj_manual)
metadata(sce)$BayesSpace.data$sample.ids <- "sample01"
# 4. Clustering
# Assicurati che selected_pca non sia superiore a 15 (default di spatialPreprocess)
# o specifica d nel preprocess se ne vuoi di piÃ¹.
sce <- BayesSpace::spatialCluster(sce = sce, q = K,
d = selected_pca,
platform = "ST",
nrep = R, burn.in = round(R/2))
# 5. Esecuzione (Prova a cambiare q in un numero fisso, es. 3, per test)
sce <- BayesSpace::spatialCluster(sce = sce,
q = K,
d = selected_pca,
platform = "ST",
nrep = R,
burn.in = round(R/2))
if(F){
knn_res <- dbscan::kNN(cbind(sce$row, sce$col), k = 6)
adj_manual <- knn_res$id
set.seed(123)
sce_colData <- cbind(row = as.numeric(as.character(round(spatialCoords(x)[,1]))),
col = as.numeric(as.character(round(spatialCoords(x)[,2]))),
colData(x))
# 1. Creazione pulita senza fronzoli
sce <- SingleCellExperiment(assays = assays(x),
rowData = rowData(x),
colData = sce_colData)
# 2. Sincronizzazione totale dei nomi (Numeri puri)
colnames(sce) <- as.character(seq_len(ncol(sce)))
rownames(sce) <- as.character(seq_len(nrow(sce))) # Reset anche dei geni se serve
sce$sample_id <- "sample01"
# 3. Preprocess standard
sce <- spatialPreprocess(sce, platform = "ST", skip.PCA = FALSE)
# 4. Iniezione manuale "blindata"
# Riduciamo la matrice adj a una matrice senza nomi, solo indici numerici
adj_raw <- as.matrix(adj_manual)
dimnames(adj_raw) <- NULL # Rimuoviamo ogni nome per evitare il check dei "nomi invalidi"
metadata(sce)$BayesSpace.data$adj <- adj_raw
metadata(sce)$BayesSpace.data$sample.ids <- "sample01"
metadata(sce)$BayesSpace.data$is.enhanced <- FALSE
# 5. Esecuzione (Prova a cambiare q in un numero fisso, es. 3, per test)
sce <- BayesSpace::spatialCluster(sce = sce,
q = K,
d = selected_pca,
platform = "ST",
nrep = R,
burn.in = round(R/2))
}
reducedDim(x)
x@metadata$glmpca$loadings
x@metadata$glmpca$loadings[,1]
plot(x@metadata$glmpca$loadings[,1])
plot(x@metadata$glmpca$loadings[,2])
x <- readRDS("Results/GLMPCA.RDS")
gg <- as.data.frame(cbind(spatialCoords(x), colData(x)[,c("perla","km","gmm")]))
gg_long <- reshape(gg,
varying = c("perla", "km", "gmm"), # Le colonne da "srotolare"
v.names = "Cluster",               # Come chiamare la colonna dei valori
timevar = "Method",                # Come chiamare la colonna dei nomi
times = c("perla", "km", "gmm"),   # I nomi da assegnare
direction = "long")                # Direzione della trasformazione
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
colData(x)$perla
spatialCoords(x)
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
# plot the clusters
ggplot(as.matrix(spatialCoords(x)), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
colData(x)$perla
class(x)
class(colData(x)$perla)
class(spatialCoords(x))
head(spatialCoords(x))
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
rlang::last_trace()
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)
# plot the clusters
ggplot(spatialCoords(x), mapping =  aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = as.numeric(colData(x)$perla)))+geom_point(cex = 4)+
theme_bw()
spatialCoords(x)
# plot the clusters
ggplot(spatialCoords(x), aes(x, y))+geom_point(cex = 4)+
theme_bw()
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = factor(colData(x)$perla)))+geom_point(cex = 4)+
theme_bw()
library(ggplot2)
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
# dependencies ------------------------------------------------------------
source("Functions/dependencies.R")
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
x <- readRDS("Results/GLMPCA.RDS")
colData(x)
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = as.integer(colData(x)$perla)))+geom_point(cex = 4)+
theme_bw()
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = integer(colData(x)$perla)))+geom_point(cex = 4)+
theme_bw()
colData(x)$perla
spatialCoords(x)
# plot the clusters
ggplot(data.frame(spatialCoords(x)), aes(x, y, col = colData(x)$perla))+geom_point(cex = 4)+
theme_bw()
# plot the clusters
ggplot(spatialCoords(x), aes(x, y, col = colData(x)$gmm))+geom_point(cex = 4)+
theme_bw()
rm(list = ls())
source("Functions/dependencies.R")
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("~/perla_to_mouse_brain/2_GLMPCA.R")
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
# using log-counts
source("2_SVgenes_logcounts.R")
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
ggplot(perla_draws, aes(x = Gene, y = Value))+
geom_boxplot()+theme_bw()+
facet_wrap(~Cluster, nrow = 3)+
geom_abline(intercept = 0, slope = 0, lty = 2)
assays(x)
rm(list = ls())
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
# using Poisson deviance residuals
source("2_SVgenes_PoissonResiduals.R")
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("Functions/align_clusters.R")
# data selection ----------------------------------------------------------
selected_genes <- 20
x <- x[rowData(x)$rank <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on poisson deviance residuals (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "poisson_deviance_residuals"))
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 2
nstart <- 5
runs_perla <- list()
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
res <- runs_perla[[which.max(lapply(runs_perla, function(y) max(y$loglik)))]]
saveRDS(res, file = "Results/perlaRun_SVgenes_PoissonResiduals.RDS")
z <- factor(apply(res$Z[,,which.max(res$loglik)], 1, function(y) which(y == 1)))
colData(x)$perla <- z
# preparing the ggplot
perla_draws <- res$Mu
dimnames(perla_draws) <- list(
Cluster = factor(1:dim(perla_draws)[1]),
Gene = colnames(selected),
Iteration = 1:dim(perla_draws)[3])
perla_draws <- as.data.frame.table(perla_draws)
colnames(perla_draws)[colnames(perla_draws) == "Freq"] <- "Value"
ggplot(perla_draws, aes(x = Gene, y = Value))+
geom_boxplot()+theme_bw()+
facet_wrap(~Cluster, nrow = 3)+
geom_abline(intercept = 0, slope = 0, lty = 2)
# k-means -----------------------------------------------------------------
set.seed(123)
km <- factor(kmeans(selected, centers = K, nstart = 10)$cluster)
colData(x)$km <- align_clusters(ref = colData(x)$perla, target = factor(km))
# GMM ---------------------------------------------------------------------
set.seed(123)
gmm <- Mclust(selected, G = K)
colData(x)$gmm <- align_clusters(ref = colData(x)$perla, target = factor(gmm$classification))
# Plot --------------------------------------------------------------------
gg <- as.data.frame(cbind(spatialCoords(x), colData(x)[,c("perla","km","gmm")]))
gg_long <- reshape(gg,
varying = c("perla", "km", "gmm"), # Le colonne da "srotolare"
v.names = "Cluster",               # Come chiamare la colonna dei valori
timevar = "Method",                # Come chiamare la colonna dei nomi
times = c("perla", "km", "gmm"),   # I nomi da assegnare
direction = "long")                # Direzione della trasformazione
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
source("~/perla_to_mouse_brain/2_SVgenes_PoissonResiduals.R")
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
rm(list = ls())
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("Functions/align_clusters.R")
# data selection ----------------------------------------------------------
selected_genes <- 20
x <- x[rowData(x)$rank <= selected_genes,]
rowData(x)
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 3
nstart <- 5
runs_perla <- list()
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
res <- runs_perla[[which.max(lapply(runs_perla, function(y) max(y$loglik)))]]
saveRDS(res, file = "Results/perlaRun_HVgenes_logcounts.RDS")
z <- factor(apply(res$Z[,,which.max(res$loglik)], 1, function(y) which(y == 1)))
colData(x)$perla <- z
# preparing the ggplot
perla_draws <- res$Mu
dimnames(perla_draws) <- list(
Cluster = factor(1:dim(perla_draws)[1]),
Gene = colnames(selected),
Iteration = 1:dim(perla_draws)[3])
perla_draws <- as.data.frame.table(perla_draws)
colnames(perla_draws)[colnames(perla_draws) == "Freq"] <- "Value"
ggplot(perla_draws, aes(x = Gene, y = Value))+
geom_boxplot()+theme_bw()+
facet_wrap(~Cluster, nrow = 3)+
geom_abline(intercept = 0, slope = 0, lty = 2)
set.seed(123)
km <- factor(kmeans(selected, centers = K, nstart = 10)$cluster)
colData(x)$km <- align_clusters(ref = colData(x)$perla, target = factor(km))
set.seed(123)
gmm <- Mclust(selected, G = K)
colData(x)$gmm <- align_clusters(ref = colData(x)$perla, target = factor(gmm$classification))
gg <- as.data.frame(cbind(spatialCoords(x), colData(x)[,c("perla","km","gmm")]))
gg_long <- reshape(gg,
varying = c("perla", "km", "gmm"), # Le colonne da "srotolare"
v.names = "Cluster",               # Come chiamare la colonna dei valori
timevar = "Method",                # Come chiamare la colonna dei nomi
times = c("perla", "km", "gmm"),   # I nomi da assegnare
direction = "long")                # Direzione della trasformazione
ggplot(gg_long, aes(x, y, col = Cluster))+
geom_point(cex = 3)+theme_bw()+
facet_wrap(~Method)
saveRDS(x, file = "Results/HVgenes_logcounts.RDS")
rm(list = ls())
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
# data selection ----------------------------------------------------------
selected_genes <- 100
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
source("Functions/align_clusters.R")
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 3
nstart <- 5
runs_perla <- list()
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
source("Functions/dependencies.R")
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("Functions/align_clusters.R")
# data selection ----------------------------------------------------------
selected_genes <- 100
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 3
nstart <- 5
runs_perla <- list()
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
# data selection ----------------------------------------------------------
selected_genes <- 20
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
rm(list = ls())
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("Functions/align_clusters.R")
# data selection ----------------------------------------------------------
selected_genes <- 20
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 3
nstart <- 5
runs_perla <- list()
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
source("Functions/dependencies.R")
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("Functions/align_clusters.R")
# data selection ----------------------------------------------------------
selected_genes <- 20
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 3
nstart <- 5
runs_perla <- list()
# data selection ----------------------------------------------------------
selected_genes <- 100
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
rm(list = ls())
x <- readRDS("processed_data.RDS")
W <- readRDS("proximity_matrix.RDS")
source("Functions/align_clusters.R")
# data selection ----------------------------------------------------------
selected_genes <- 100
x <- x[rowData(x)$rank_binomial_deviance <= selected_genes,]
plot(rowData(x)$rank_binomial_deviance, rowData(x)$rank,
xlab = "deviance rank", ylab = "spatial rank")
# fitting perla on logcounts (centered) -----------------------------------------------------------
selected <- t(assay(x,
i = "logcounts"))
selected <- selected - mean(selected)
boxplot(selected);abline(h = 0, lty = 2)
heatmap(selected)
R <- 5*10^3
K <- 3
nstart <- 5
runs_perla <- list()
for(i in 1:nstart){
runs_perla[[i]] <- perla(y = selected, W = W, K = K, R = R,
mean.penalty = c("d","cd"), burnin = 1:(R/2), seed = 1234*i)
runs_perla[[i]] <- perla::recover.loglikelihood(runs_perla[[i]])
}
